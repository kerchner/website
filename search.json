[
  {
    "objectID": "question-types.html",
    "href": "question-types.html",
    "title": "Question Types",
    "section": "",
    "text": "All questions in a surveydown survey are created using the sd_question() function.\nThe function requires the following three arguments:\n\nid: A unique identifier for the question, which will be used as the variable name in the resulting survey data.\nlabel: The label that will be displayed on the question in the survey.\ntype: The type of question.\n\nMany question types also require an option argument, which is a named vector of options for the question (e.g. for multiple choice questions).\nThe function also includes many other optional arguments that can be used to customize the question appearance and behavior. See the package documentation for more details.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Types"
    ]
  },
  {
    "objectID": "question-types.html#introduction-to-sd_question",
    "href": "question-types.html#introduction-to-sd_question",
    "title": "Question Types",
    "section": "",
    "text": "All questions in a surveydown survey are created using the sd_question() function.\nThe function requires the following three arguments:\n\nid: A unique identifier for the question, which will be used as the variable name in the resulting survey data.\nlabel: The label that will be displayed on the question in the survey.\ntype: The type of question.\n\nMany question types also require an option argument, which is a named vector of options for the question (e.g. for multiple choice questions).\nThe function also includes many other optional arguments that can be used to customize the question appearance and behavior. See the package documentation for more details.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Types"
    ]
  },
  {
    "objectID": "question-types.html#question-types",
    "href": "question-types.html#question-types",
    "title": "Question Types",
    "section": "Question Types",
    "text": "Question Types\nThe following question types are supported by {surveydown}:\n\ntext: Single line open text input.\ntextarea: Multiple line open text input.\nnumeric: Single line numeric text input.\nmc: Multiple choice with a single select option (radio buttons).\nmc_buttons: Same as mc but as a “button” style instead of radio buttons.\nmc_multiple: Multiple choice with mutliple select options (check boxes).\nmc_multiple_buttons: Same as mc_multiple but as a “button” style instead of check boxes.\nselect: Select a choice from a drop down menu.\nslider: (Under construction) Slider to select discrete categories or continuous numbers.\ndate: Select a date from a calendar widget.\ndaterange: Select two dates from calendar widgets (e.g. begin and end dates).\n\nBelow are examples of each question type.\n\ntext\nUse type = 'text' to specify a text input type question.\nCode chunk:\n\n```{r}\nsd_question(\n  type  = \"text\",\n  id    = \"word\",\n  label = \"Write a word:\"\n)\n```\n\nOutput:\n\n\n\n\nWrite a word: *\n\n\n\n\n\n\n\n\ntextarea\nUse type = 'textarea' to specify a text area input type question.\nCode chunk:\n\n```{r}\nsd_question(\n  type  = \"textarea\",\n  id    = \"paragraph\",\n  label = \"Write a paragraph:\"\n)\n```\n\nOutput:\n\n\n\n\nWrite a paragraph: *\n\n\n\n\n\n\n\n\nnumeric\nUse type = 'numeric' to specify a numeric input type.\nCode chunk:\n\n```{r}\nsd_question(\n  type  = 'numeric',\n  id    = 'age',\n  label = \"What's your age?\"\n)\n```\n\nOutput:\n\n\n\n\nWhat’s your age? *\n\n\n\n\n\n\n\n\nmc\nUse type = 'mc' to specify a multiple choice type question with a single choice option.\nCode chunk:\n\n```{r}\nsd_question(\n  type   = 'mc',\n  id     = 'artist',\n  label  = \"Which artist do you prefer most from this list?\",\n  option = c(\n    \"Taylor Swift\" = \"taylor_swift\",\n    \"Beyoncé\"      = \"beyonce\",\n    \"Adele\"        = \"adele\",\n    \"Rihanna\"      = \"rihanna\",\n    \"Lady Gaga\"    = \"ladygaga\",\n    \"Ed Sheeran\"   = \"ed_sheeran\",\n    \"Drake\"        = \"drake\"\n  )\n)\n```\n\nOutput:\n\n\n\n\nWhich artist do you prefer most from this list? *\n\n\n\n\n\nTaylor Swift\n\n\n\n\n\nBeyoncé\n\n\n\n\n\nAdele\n\n\n\n\n\nRihanna\n\n\n\n\n\nLady Gaga\n\n\n\n\n\nEd Sheeran\n\n\n\n\n\nDrake\n\n\n\n\n\n\n\n\n\nmc_buttons\nUse type = 'mc_buttons' to generate the button version of mc.\nCode chunk:\n\n```{r}\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'fruit',\n  label  = \"Which fruit do you prefer most from this list?\",\n  option = c(\n    \"Apple\"      = \"apple\",\n    \"Banana\"     = \"banana\",\n    \"Pear\"       = \"pear\",\n    \"Strawberry\" = \"strawberry\",\n    \"Grape\"      = \"grape\",\n    \"Mango\"      = \"mango\",\n    \"Watermelon\" = \"watermelon\"\n  )\n)\n```\n\nOutput:\n\n\n\n\nWhich fruit do you prefer most from this list? *\n\n\n\n\n\nApple\n\nBanana\n\nPear\n\nStrawberry\n\nGrape\n\nMango\n\nWatermelon\n\n\n\n\n\n\n\n\nmc_multiple\nUse type = 'mc_multiple' to specify a multiple choice type question with multiple selection enabled.\nCode chunk:\n\n```{r}\nsd_question(\n  type  = 'mc_multiple',\n  id    = 'swift',\n  label = \"What are your favorite Taylor Swift albums (select all that apply)?\",\n  option = c(\n    \"Taylor Swift (2006)\" = \"taylor_swift\",\n    \"Fearless (2008)\"     = \"fearless\",\n    \"Speak Now (2010)\"    = \"speak_now\",\n    \"Red (2012)\"          = \"red\",\n    \"1989 (2014)\"         = \"1989\",\n    \"Reputation (2017)\"   = \"reputation\",\n    \"Lover (2019)\"        = \"lover\",\n    \"Folklore (2020)\"     = \"folklore\",\n    \"Evermore (2020)\"     = \"evermore\",\n    \"Midnights (2022)\"    = \"midnights\"\n  )\n)\n```\n\nOutput:\n\n\n\n\nWhat are your favorite Taylor Swift albums (select all that apply)? *\n\n\n\n\n\nTaylor Swift (2006)\n\n\n\n\n\nFearless (2008)\n\n\n\n\n\nSpeak Now (2010)\n\n\n\n\n\nRed (2012)\n\n\n\n\n\n1989 (2014)\n\n\n\n\n\nReputation (2017)\n\n\n\n\n\nLover (2019)\n\n\n\n\n\nFolklore (2020)\n\n\n\n\n\nEvermore (2020)\n\n\n\n\n\nMidnights (2022)\n\n\n\n\n\n\n\n\n\nmc_multiple_buttons\nUse type = 'mc_multiple_buttons' to generate the button version of mc_multiple.\nCode chunk:\n\n```{r}\nsd_question(\n  type  = 'mc_multiple_buttons',\n  id    = 'michael_jackson',\n  label = \"Which are your favorite Michael Jackson songs (select all that apply)?\",\n  option = c(\n    \"Thriller (1982)\"          = \"thriller\",\n    \"Billie Jean (1982)\"       = \"billie_jean\",\n    \"Beat It (1982)\"           = \"beat_it\",\n    \"Man in the Mirror (1987)\" = \"man_in_the_mirror\",\n    \"Smooth Criminal (1987)\"   = \"smooth_criminal\",\n    \"Black or White (1991)\"    = \"black_or_white\",\n    \"Bad (1987)\"               = \"bad\",\n    \"Human Nature (1982)\"      = \"human_nature\"\n  )\n)\n```\n\nOutput:\n\n\n\n\nWhich are your favorite Michael Jackson songs (select all that apply)? *\n\n\n\n\n\nThriller (1982)\n\nBillie Jean (1982)\n\nBeat It (1982)\n\nMan in the Mirror (1987)\n\nSmooth Criminal (1987)\n\nBlack or White (1991)\n\nBad (1987)\n\nHuman Nature (1982)\n\n\n\n\n\n\n\n\nselect\nUse type = 'select' to specify a drop down select type question.\nCode chunk:\n\n```{r}\nsd_question(\n  type  = 'select',\n  id    = 'education',\n  label = \"What is the highest level of education you have attained?\",\n  option = c(\n    \"Did not attend high school\" = \"hs_no\",\n    \"Some high school\"           = \"hs_some\",\n    \"High school graduate\"       = \"hs_grad\",\n    \"Some college\"               = \"college_some\",\n    \"College\"                    = \"college_grad\",\n    \"Graduate Work\"              = \"grad\",\n    \"Prefer not to say\"          = \"no_response\"\n  )\n)\n```\n\nOutput:\n\n\n\n\nWhat is the highest level of education you have attained? *\n\n\nChoose an option...\nDid not attend high school\nSome high school\nHigh school graduate\nSome college\nCollege\nGraduate Work\nPrefer not to say\n\n\n\n\n\n\n\n\nslider (Under Construction)\nDue to compatibility issues, the slider type is still under construction.\n\n\ndate\nUse type = 'date' to specify a date input type.\nCode chunk:\n\n```{r}\nsd_question(\n  type  = 'date',\n  id    = 'dob',\n  label = \"What is your date of birth?\"\n)\n```\n\nOutput:\n\n\n\n\nWhat is your date of birth? *\n\n\n\n\n\n\n\nThe date value will be today’s date by default. Upon clicking on the text box, you are provided with a date dialog box to choose date from.\n\n\n\n\n\n\nNote\n\n\n\nThe dialog box will only appear in a Shiny environment, hence why it is not appearing when clicked here.\n\n\n\n\ndaterange\nUse type = 'daterange' to specify a date range input type.\nCode chunk:\n\n```{r}\nsd_question(\n  type  = 'daterange',\n  id    = 'hs_date',\n  label = \"When did you start and finish high school?\"\n)\n```\n\nOutput:\n\n\n\n\nWhen did you start and finish high school? *\n\n\n\n\n-\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe dialog box will only appear in a Shiny environment, hence why it is not appearing when clicked here.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Question Types"
    ]
  },
  {
    "objectID": "survey-components.html",
    "href": "survey-components.html",
    "title": "Survey Components",
    "section": "",
    "text": "This guide covers the main elements in your .qmd survey file as well as how to add content to your survey, like pages, questions, etc.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Survey Components"
    ]
  },
  {
    "objectID": "survey-components.html#overview",
    "href": "survey-components.html#overview",
    "title": "Survey Components",
    "section": "Overview",
    "text": "Overview\nEvery surveydown survey is configured in a single .qmd file that consists of 4 parts:\n\nThe YAML header.\nThe setup code chunk.\nThe survey body.\nThe server code chunk.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Survey Components"
    ]
  },
  {
    "objectID": "survey-components.html#yaml-header",
    "href": "survey-components.html#yaml-header",
    "title": "Survey Components",
    "section": "1. YAML Header",
    "text": "1. YAML Header\nThe YAML header is at the top of the .qmd file. In addition to two required elements, the YAML can be used to set the survey theme as well as modify the survey progress bar.\n\nRequired content\nFor a surveydown survey, your YAML must contain at least the following:\n---\nserver: shiny\nfilters: [surveydown]\n---\nThe server: shiny part ensures that the document will render as a Shiny app. The filters: [surveydown] part applies the surveydown Quarto extension to the project, which is required.\n\n\nSetting the theme\nThe YAML can also be used to set several optional global settings, such as the overall survey theme:\n---\ntheme: united # Any bootswatch theme \n---\nThere are 25 bootswatch themes to choose from. You can also provide a custom.scss file to further modify the theme, or even combine the two, e.g.:\n---\ntheme: [united, custom.scss]\n---\n\n\nProgress bar\nYou can modify the survey progress bar with the barcolor and barposition keys, e.g.:\n---\nbarcolor: theme \nbarposition: top \n---\nThe barcolor key defines the color of the progress bar. It defaults to theme, meaning it will take the primary theme color. You may also use any hex code to overwrite this color as you wish, e.g.: #768692.\nThe barposition key defines the position of the progress bar. It defaults to top, but can also be changed to bottom or none (to remove the bar). The progress bar updates on every question the user clicks on, not pages.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Survey Components"
    ]
  },
  {
    "objectID": "survey-components.html#setup-code-chunk",
    "href": "survey-components.html#setup-code-chunk",
    "title": "Survey Components",
    "section": "2. Setup code chunk",
    "text": "2. Setup code chunk\nAfter the YAML header, you’ll need to load the surveydown package and run the sd_setup() function. This should be placed inside a code chunk that looks like this:\n\n```{r}\n#| context: setup\n#| warning: false\n#| message: false\n\n# Load the package\nlibrary(surveydown)\n\n# Run initial setup function (essential - do not delete)\nsd_setup()\n```\n\nAnything loaded in the setup chunk is accessible in both your survey body and your server, so we recommend also loading other packages and / or data in this chunk as well.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Survey Components"
    ]
  },
  {
    "objectID": "survey-components.html#survey-body",
    "href": "survey-components.html#survey-body",
    "title": "Survey Components",
    "section": "3. Survey body",
    "text": "3. Survey body\nThe survey body is all the content in between your setup code chunk and your server code chunk. You can use markdown (or the RStudio visual editor) to insert text, images, etc. just like you would in any Quarto document.\nThe unique elements to a surveydown survey are pages, navigation buttons, and questions.\n\nAdding pages\nIn surveydown, pages are defined using fences (:::), like this:\n\n::: {#welcome .sd-page}\n\nPage 1 content here\n\n:::\n\n::: {#page2 .sd-page}\n\nPage 2 content here\n\n:::\n\nAs you can see, we use three colon symbols :::, called a “fence”, to mark the start and end of pages. This notation is commonly used in Quarto for a variety of use cases, like defining subfigures in images.\nIn the starting fence, you need to define a page name (e.g. welcome and page2 in the example above) and you need to define the class as .sd-page. Then anything you put between the page fences will appear on that page.\n\n\nAdding navigation buttons\nTo navigate to the next page, you need to insert a sd_next() function call inside a code chunk, like this:\n\n```{r}\nsd_next(next_page = 'page2')\n```\n\nThe above code chunk will create a “Next” button that goes on to page 2 that looks like this:\n\n\nNext\n\n\nIn this example, the next button has to be inserted in a code chunk in between the ::: fences of the welcome page in order to have a “Next” button that goes on to page 2. You can also send the user to other pages by just changing the value assigned to the next_page argument.\nFinally, you can also change the label of the button by changing the label argument, like this:\n\n```{r}\nsd_next(next_page = 'page2', label = 'Next page')\n```\n\n\n\nNext page\n\n\n\n\nEnding the survey\nTo end a survey, all you have to do is create a page with no sd_next() button on it. This will effectively serve as a ending page, because the respondent will not be able to navigate anywhere else once reaching a page with no sd_next() button.\nFor example, you may want to have a screen-out page that respondents are sent to if they answer a certain way on a question (see the basic skipping page for an example). You can do this by creating a page with no sd_next() button on it, like this:\n\n::: {#screenout .sd-page}\n\nScreenout page content here\n\n:::\n\nWhen a respondent reaches this page, they will not be able to navigate anywhere else, so the survey is over.\n\n\nAdding questions\nEvery survey question is created using the sd_question() function inside a code chunk. The question type is defined by the type argument. For example, to add a multiple choice question, you could insert the following code chunk:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n```\n\nThe above code chunk will create a multiple choice question that looks like this:\n\n\n\n\nWhich is your favorite type of penguin? *\n\n\n\n\n\nAdélie\n\n\n\n\n\nChinstrap\n\n\n\n\n\nGentoo\n\n\n\n\n\n\n\n\nThe sd_question() function can be used to create a variety of question types, like text input, select drop down choices, and more by changing the type argument (see the Questions Types page).\nThe function has many other arguments for customizing the look and feel of the question, such as the height and width (see the Formatting Questions page).\nBy default all questions are optional, but you can make questions required in the configuration options (see the Configuration Options page for details).",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Survey Components"
    ]
  },
  {
    "objectID": "survey-components.html#server-code-chunk",
    "href": "survey-components.html#server-code-chunk",
    "title": "Survey Components",
    "section": "4. Server code chunk",
    "text": "4. Server code chunk\nAt the very bottom of the .qmd file is a special “server” code chunk (that’s the #| context: server bit) that defines the app server. This is where you can customize and control the survey flow logic as well as where you define the database that will store the survey response data. It looks like this:\n\n```{r}\n#| context: server\n\n# Define the configuration settings\nconfig &lt;- sd_config()\n\n# Define the database settings\ndb &lt;- sd_database()\n\n# The sd_server() function initiates your survey - don't change this\nsd_server(\n  input   = input,\n  session = session,\n  config  = config,\n  db      = db\n)\n```\n\nThe sd_config() function is where you can define configuration options for the survey, such as conditional display (conditionally displaying a question based on responses to questions), or conditional skip (conditionally sending the respondent to a page based on responses to questions). See the Configuration Options page for details.\nThe sd_database() function is where you set up your database. See the Store Data page for details.\nThe sd_server() function at the bottom makes everything run, which you can safely ignore - just don’t change it and all will be good!",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Survey Components"
    ]
  },
  {
    "objectID": "formatting.html",
    "href": "formatting.html",
    "title": "Formatting Questions",
    "section": "",
    "text": "The sd_question() function has many optional arguments for modifying the appearance and behavior of questions. This page demonstrates some of the formatting options.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Formatting"
    ]
  },
  {
    "objectID": "formatting.html#markdown-formatting",
    "href": "formatting.html#markdown-formatting",
    "title": "Formatting Questions",
    "section": "Markdown formatting",
    "text": "Markdown formatting\nMarkdown is supported for question labels and option labels.\n\nQuestion labels\nThe label argument for any question type can accept markdown formatting. For example, the question below uses the * symbol to make some words bold, italic, and bold italic.\nCode chunk:\n\n```{r}\nsd_question(\n  type   = 'mc',\n  id     = 'markdown_label',\n  label  = \"**This** is a question *label* supporting ***markdown***:\",\n  option = c(\n    \"Option A\" = \"option_a\",\n    \"Option B\" = \"option_b\",\n    \"Option C\" = \"option_c\"\n  )\n)\n```\n\nOutput:\n\n\n\n\nThis is a question label supporting markdown: *\n\n\n\n\n\nOption A\n\n\n\n\n\nOption B\n\n\n\n\n\nOption C\n\n\n\n\n\n\n\n\n\nOption labels\nMarkdown formatting is also supported for the option labels in question types that have options, such as mc, mc_multiple, mc_buttons, and mc_multiple_buttons. For example:\nCode chunk:\n\n```{r}\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'markdown_buttons',\n  label  = \"The 3 options below support markdown:\",\n  option = c(\n    \"*Option A*\"     = \"option_a\",\n    \"**Option B**\"   = \"option_b\",\n    \"***Option C***\" = \"option_c\"\n  )\n)\n```\n\nOutput:\n\n\n\n\nThe 3 options below support markdown: *\n\n\n\n\n\nOption A\n\nOption B\n\nOption C",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Formatting"
    ]
  },
  {
    "objectID": "formatting.html#html-formatting",
    "href": "formatting.html#html-formatting",
    "title": "Formatting Questions",
    "section": "HTML formatting",
    "text": "HTML formatting\nHTML formatting is supported for the option labels in question types that have options, such as mc_buttons and mc_multiple_buttons. This allows you to insert mixed content to achieve more complex labels, including plain text, markdown, and HTML code.\nFor example, here is a question with some complex labels for a choice question that include markdown and HTML code to embed images.\nCode chunk:\n\n```{r}\n# Define the option vector\nhtml_button_options &lt;- c(\"option_1\", \"option_2\", \"option_3\")\n\n# Define option labels that include markdown and HTML code to embed images\nnames(html_button_options) &lt;- c(\n\n  \"**Option 1**&lt;br&gt;\n   &lt;img src='https://raw.githubusercontent.com/surveydown-dev/demo-conjoint-survey/main/images/fuji.jpg' width=100&gt;&lt;br&gt;\n   **Type**: Fuji&lt;br&gt;\n   **Price**: $ 2 / lb&lt;br&gt;\n   **Freshness**: Average\",\n\n  \"**Option 2**&lt;br&gt;\n   &lt;img src='https://raw.githubusercontent.com/surveydown-dev/demo-conjoint-survey/main/images/pinkLady.jpg' width=100&gt;&lt;br&gt;\n    **Type**: Pink Lady&lt;br&gt;\n    **Price**: $ 1.5 / lb&lt;br&gt;\n    **Freshness**: Excellent\",\n\n  \"**Option 3**&lt;br&gt;\n    &lt;img src='https://raw.githubusercontent.com/surveydown-dev/demo-conjoint-survey/main/images/honeycrisp.jpg' width=100&gt;&lt;br&gt;\n    **Type**: Honeycrisp&lt;br&gt;\n    **Price**: $ 2 / lb&lt;br&gt;\n    **Freshness**: Poor\"\n)\n\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'html_buttons',\n  label  = \"A sample survey question using `mc_buttons`\",\n  option = html_button_options\n)\n```\n\nOutput:\n\n\n\n\nA sample survey question using mc_buttons *\n\n\n\n\n\nOption 1Type: FujiPrice: $ 2 / lbFreshness: Average\n\nOption 2Type: Pink LadyPrice: $ 1.5 / lbFreshness: Excellent\n\nOption 3Type: HoneycrispPrice: $ 2 / lbFreshness: Poor",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Formatting"
    ]
  },
  {
    "objectID": "formatting.html#size-formatting",
    "href": "formatting.html#size-formatting",
    "title": "Formatting Questions",
    "section": "Size formatting",
    "text": "Size formatting\nUse the width, height arguments to change the size of the question.\nFor example, the question below uses the width and height arguments to change the size of a text area question.\nCode chunk:\n\n```{r}\nsd_question(\n  type  = \"textarea\",\n  id    = \"change_width\",\n  label = \"This text area has width set as 40% and height set as 100px:\",\n  width = \"40%\", \n  height = \"100px\"\n)\n```\n\nOutput:\n\n\n\n\nThis text area has width set as 40% and height set as 100px: *",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Formatting"
    ]
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "",
    "text": "Because surveydown surveys run as a shiny app, you can include custom logic in the background by writing some  code in your server. In this post, I’m going to show you one approach for using surveydown to create a particular type of complex survey: a choice-based conjoint survey.\nThe key component of a choice-based conjoint survey is asking repsondents to make choices from randomized sets of choice questions. So the hard part is figuring out a way to show each respondent a different set of randomized questions. This post shows how you can achieve this in surveydown.\nThroughout this post, I will use a demo survey about people’s preferences for apples with three attributes: type, price, and freshness.1\nYou can view the live demo survey here, and all files used to create the survey are on this GitHub repo."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#introduction",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#introduction",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Introduction",
    "text": "Introduction\nIf you’ve never used surveydown before, take a look at this post to get a quick introduction to the package and how to use it to make a survey.\nThe basic concept is:\n\nDesign your survey as a Quarto shiny document using markdown and R code.\nRender your doc into a shiny app that can be hosted online and sent to respondents.\nStore your survey responses in a supabase database."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#getting-started",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#getting-started",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Getting started",
    "text": "Getting started\nIf you want to start from a blank slate, take a look at the Get Started documentation page.\nFor this post, we recommend starting from the demo survey available at this GitHub repo. It provides an already working survey that you can modify to the needs of your conjoint survey.\nThe demo repo has a lot of files in it, but the main files defining the survey itself are:\n\nsurvey.qmd: The main body of the survey.\nserver.R: The server defining the logic implemented in the survey, including randomizing questions, connecting to a database, etc.\n\nIn a typical surveydown survey, our server code chunk (bottom of the survey.qmd file) is not that long, so we just keep everything there. However, in this case since we have a lot more going on in our server, we chose to use a split file structure where we separate out most of the server code in a separate server.R file. We then source that file in the server code chunk (the source(\"server.R\") part in our server code chunk). This just makes it easier to edit the server code as the server.R file can be opened in a separate tab rather than having to scroll up and down the longer survey.qmd file.\n\n\n\n\n\n\nNote\n\n\n\nWe recommend opening the survey.Rproj if you’re working in RStudio to make sure RStudio opens to the correct project folder."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#content-in-the-survey-body",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#content-in-the-survey-body",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Content in the survey body",
    "text": "Content in the survey body\nAfter the setup code chunk, we have a series of pages (defined with ::: fences) that include markdown-formatted text and survey questions (defined with sd_question()). You can modify any of this content as you wish to suit the needs of your survey.\nIn this demo, we have a few other examples included, like a conditionally displayed question (the fav_fruit question will not display if you choose “No” on the first question about liking fruit) as well as a question that skips people to the end (if you choose “blue” and not “red” on the screening page). The logic controlling the conditional display and skipping is defined in the sd_config() function inside the server.R file.\nNone of this is necessary for a conjoint survey, but often times these are features that you may want to include, such as screening people out of the survey if they don’t qualify to take it, so we include it for demonstration purposes."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#defining-the-choice-questions",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#defining-the-choice-questions",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Defining the choice questions",
    "text": "Defining the choice questions\nThe central component of every conjoint survey is the set of randomized choice questions. To implement these in surveydown, we pre-define our choice questions in a design file that we later use in the survey to select randomized sets of choice questions to display each respondent.\nWe use the cbcTools package to create the pre-defined design file. The code to create the choice questions for this demo survey is in the make_choice_questions.R file in the demo repo. This code generates a data frame of randomized choice questions that we then save in the project directory as choice_questions.csv."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#implementing-the-choice-questions",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#implementing-the-choice-questions",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Implementing the choice questions",
    "text": "Implementing the choice questions\nThe choice questions are implemented at the top of the server.R file in the demo repo. This code does the following steps:\n\n1. Read in the design file\nPretty straightforward - this is one line to read in the choice_questions.csv design file that we saved in the project folder.\n\ndesign &lt;- readr::read_csv(\"choice_questions.csv\")\n\n\n\n2. Sample and store a random respondent ID\nSince we want each respondent to see a different set of choice questions, we randomly sample a respondent ID from the set of all respondent IDs in the design file. We also need to keep track of this and store it in our response data so that later we can know what each respondent was actually shown.\nSince this is a value that we generated in the server (and not a value from a survey question to a respondent), we have to manually add it to the survey response data using sd_store_value(). Here we modified the name so that in the resulting survey data the column name will be \"respID\".\n\n# Sample a random respondentID\nrespondentID &lt;- sample(design$respID, 1)\n\n# Store the respondentID\nsd_store_value(respondentID, \"respID\")\n\n\n\n3. Filter the design for the respondentID\nWe create a subset dataframe called df that stores only the rows for the randomly chosen respondent ID. We also append the \"images/\" string onto the values in the image column as this will create the relative path to the images in our survey, e.g. \"images/fuji.jpg\" (all the images we show are in the \"images\" folder in the repo).\n\n# Filter for the rows for the chosen respondentID\ndf &lt;- design %&gt;%\n  filter(respID == respondentID) %&gt;%\n  mutate(image = paste0(\"images/\", image))\n\n\n\n4. Define a function to create question options\nThis is the most complex component in the server logic. Here we created a function that takes a dataframe and returns a named vector defining the options to show in each choice question. In this case, we only have 3 options per choice question, so each time we call this function we will use a small dataframe that has just 3 rows defining the 3 choice alternatives in a single choice question.\nThe function does several things. First, it extracts three single-row data frames that store the values of each of the 3 alternatives (alt1, alt2, and alt3). It then creates an options vector that has just 3 values: \"option_1\", \"option_2\", and \"option_3\". Then we have to define the names of each of those options. Remember that the values in the options vector are what gets stored in our resulting survey data based on what the respondent chooses, but the names are what respondents see. So in the context of a choice survey like this, we need to embed all of the attributes and their levels in the names of the options vector.\nWe use the glue() function to easily inject the values stored in alt1, alt2, and alt3 into our labels. The glue() function is similar to paste() in that is just concatenates object values into a string, but it has an easier syntax to work with. Anything inside {} brackets is evaluated, and the resulting value is inserted into the string. So for example, the line glue(\"1 plus 1 equals {1+1}\") would produce the string \"1 plus 1 equals 2\".\nIn our case, we’re including some html code to insert an image of the apple type (&lt;img src='{alt1$image}' width=100&gt;), the apply type itself (**Type**: {alt1$type}), and the apple price (**Price**: $ {alt1$price} / lb).\nNotice also that we’re mixing markdown (e.g. **Option 1**) and html (e.g. &lt;br&gt;), which will all get rendered into proper html in the resulting shiny app. The full function looks like this:\n\n# Function to create the labels for a choice question\n# based on the values in df\n\nmake_cbc_options &lt;- function(df) {\n  alt1 &lt;- df |&gt; filter(altID == 1)\n  alt2 &lt;- df |&gt; filter(altID == 2)\n  alt3 &lt;- df |&gt; filter(altID == 3)\n\n  options &lt;- c(\"option_1\", \"option_2\", \"option_3\")\n\n  names(options) &lt;- c(\n    glue(\"\n      **Option 1**&lt;br&gt;\n      &lt;img src='{alt1$image}' width=100&gt;&lt;br&gt;\n      **Type**: {alt1$type}&lt;br&gt;\n      **Price**: $ {alt1$price} / lb\n    \"),\n    glue(\"\n      **Option 2**&lt;br&gt;\n      &lt;img src='{alt2$image}' width=100&gt;&lt;br&gt;\n      **Type**: {alt2$type}&lt;br&gt;\n      **Price**: $ {alt2$price} / lb\n    \"),\n    glue(\"\n      **Option 3**&lt;br&gt;\n      &lt;img src='{alt3$image}' width=100&gt;&lt;br&gt;\n      **Type**: {alt3$type}&lt;br&gt;\n      **Price**: $ {alt3$price} / lb\n    \")\n  )\n  return(options)\n}\n\n\n\n5. Create the options for each choice question\nOne of the benefits of making the function the way we did in the previous step is that we can now easily call it to generate the option vector for each of the 6 choice questions in df:\n\n# Create the options for each choice question\n\ncbc1_options &lt;- make_cbc_options(df |&gt; filter(qID == 1))\ncbc2_options &lt;- make_cbc_options(df |&gt; filter(qID == 2))\ncbc3_options &lt;- make_cbc_options(df |&gt; filter(qID == 3))\ncbc4_options &lt;- make_cbc_options(df |&gt; filter(qID == 4))\ncbc5_options &lt;- make_cbc_options(df |&gt; filter(qID == 5))\ncbc6_options &lt;- make_cbc_options(df |&gt; filter(qID == 6))\n\n\n\n6. Create each choice question (6 in total)\nFinally, we now have everything we need to generate each choice question. Here we’re using the mc_buttons question type so that the labels we generated will be displayed on a large button, which looks good both on a computer and phone. We give the question a unique id (e.g. cbc_q1), and a label, and then set the option to the corresponding option vector we defined above.\n\nsd_question(\n  type   = 'mc_buttons',\n  id     = 'cbc_q1',\n  label  = \"(1 of 6) If these were your only options, which would you choose?\",\n  option = cbc1_options,\n  reactive = TRUE\n)\n\n# ...and 5 more questions like this\n\nNote here the final argument: reactive = TRUE. Since the labels in the options are being dynamically generated on each new session (each respondent), they have to be created in the server, not in the main survey body. As a result, the sd_question() function must also be created in the server code (if you put this code in the main body, only one random set of choice options will be generated, and they’ll be the same for everyone).\nBy setting reactive = TRUE, we’re telling surveydown that this question should not be displayed here, it just needs to generate the question and store it’s id. Then in the survey body we tell it where to display the question with sd_display_question('id'), changing id to each corresponding choice question we created. In the demo survey.qmd file, you’ll see that there are 6 choice questions displayed in the main survey body (each on their own page), and each of those 6 questions are defined in the server.R file.\nWhen rendered, a choice question will look like this, with the values matching whatever alternative was chosen in the design file:\n\n\n\n\n(1 of 6) If these were your only options, which would you choose? *\n\n\n\n\n\nOption 1Type: HoneycrispPrice: $ 1 / lb\n\nOption 2Type: FujiPrice: $ 3 / lb\n\nOption 3Type: Red DeliciousPrice: $ 2.5 / lb\n\n\n\n\n\n\n\nAnd that’s it! You now have 6 randomized choice questions!"
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#preview-and-check",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#preview-and-check",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Preview and check",
    "text": "Preview and check\nThe rest of the server.R file has the remaining components we need to establish a database connection (with sd_database()) and include any conditional display or skip logic (with sd_config()). This is all standard features of any surveydown survey, so we won’t cover them in detail here and instead direct you to the documentation for details.\nBut before you go live, it’s a good idea to do some quick testing. You can test your survey even without having it connected to a database by setting pause  = TRUE in the sd_database() function. Of course, you probably should also test it after connecting it to a database to ensure that responses are being properly stored.\nWhen testing, you’ll probably get an error - don’t panic! Read the terminal output carefully and debug. There’s a good chance you may have missed a bug somewhere in your server code. But since it’s in a separate server.R file, you should be able to open this and run through your code to check that things are working properly."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#getting-the-data",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#getting-the-data",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Getting the data",
    "text": "Getting the data\nOnce your survey is live and you start collecting responses, you can easily access your data with the sd_get_data() function. This is typically done in a separate R file, which might look something like this:\n\nlibrary(surveydown)\n\ndb &lt;- sd_database(\n  user   = 'postgres.axzkymswaxcasjdflkurrj',\n  host   = 'aws-0-us-east-1.pooler.supabase.com',\n  port   = 5678,\n  db_name = 'postgres',\n  table_name = 'my_table'\n)\n\ndata &lt;- sd_get_data(db)\n\nObviously your settings in sd_database() would need to match those of your Supabase database that you created for your survey.\nAnd that’s it! We hope this post was helpful, and do go check out the this GitHub repo to try out the demo yourself."
  },
  {
    "objectID": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#footnotes",
    "href": "blog/2024-08-28-choice-based-conjoint-surveys-with-surveydown/index.html#footnotes",
    "title": "Choice-based conjoint surveys in R with surveydown",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nYes, people have actually done conjoint surveys on fruit before.↩︎"
  },
  {
    "objectID": "installation.html",
    "href": "installation.html",
    "title": "Installation",
    "section": "",
    "text": "You need both:\n\nInstall \nInstall Quarto\n\nAlso, we recommend working with an IDE. RStudio is great, and we also like VS Code and Positron.",
    "crumbs": [
      "Documentation",
      "Installation"
    ]
  },
  {
    "objectID": "installation.html#install-r-quarto",
    "href": "installation.html#install-r-quarto",
    "title": "Installation",
    "section": "",
    "text": "You need both:\n\nInstall \nInstall Quarto\n\nAlso, we recommend working with an IDE. RStudio is great, and we also like VS Code and Positron.",
    "crumbs": [
      "Documentation",
      "Installation"
    ]
  },
  {
    "objectID": "installation.html#install-the-surveydown-r-package",
    "href": "installation.html#install-the-surveydown-r-package",
    "title": "Installation",
    "section": "Install the {surveydown} R package",
    "text": "Install the {surveydown} R package\nThe {surveydown} R package is not yet on CRAN, but you can install the development version from GitHub with the following command in your R console:\n\n# install.packages(\"remotes\")\nremotes::install_github(\"surveydown-dev/surveydown\")",
    "crumbs": [
      "Documentation",
      "Installation"
    ]
  },
  {
    "objectID": "installation.html#install-the-surveydown-quarto-extension",
    "href": "installation.html#install-the-surveydown-quarto-extension",
    "title": "Installation",
    "section": "Install the surveydown Quarto Extension",
    "text": "Install the surveydown Quarto Extension\nOnce you start working on an actual survey, you’ll need the surveydown Quarto extension.\n\nNote: The extension must be locally installed in a _extensions folder in your root survey project folder.\n\nWe recommend starting with a template survey, which will automatically add the latest extension for you:\n\nsurveydown::sd_create_survey(\"path/to/folder\")\n\nOtherwise, you can install the extension using the terminal or with the {surveydown} package:\n\nUsing the Terminal:\n\n\nquarto install extension jhelvy/surveydown-ext\n\n\nUsing the {surveydown} R package:\n\n\nsurveydown::sd_update_extension()",
    "crumbs": [
      "Documentation",
      "Installation"
    ]
  },
  {
    "objectID": "installation.html#version-control",
    "href": "installation.html#version-control",
    "title": "Installation",
    "section": "Version Control",
    "text": "Version Control\nWe made some R functions to make it easier to keep your R package and Quarto extension up to date.\nTo check if you have the latest R package and Quarto extension installed, run:\n\nsurveydown::sd_check_versions()\n\nTo update the R package and Quarto extension to the latest version, run:\n\nsurveydown::sd_update_surveydown()",
    "crumbs": [
      "Documentation",
      "Installation"
    ]
  },
  {
    "objectID": "documentation.html",
    "href": "documentation.html",
    "title": "surveydown.org",
    "section": "",
    "text": "Welcome to your first surveydown survey!\nWe recommend reading the Get Started page to get a sense of how to use surveydown. The rest of the documentation covers more details on how to use surveydown.\n\nGet Started!\n\n\n\nFeatures\n\n\n\n\n    \n\n    \n    \n      \n        \n        \n              \n                Progress\n                Feature\n                Implementation\n              \n        \n        \n        \n                \n                                       \n                  Wide variety of question types                                                          \n                  sd_question()                                                                                             \n                \n                \n                                       \n                  Ability to use latest survey results in the survey itself                 \n                  sd_get_data(db, reactive = TRUE)                                                                          \n                \n                \n                                       \n                  Preview mode (pauses database connection)                                                                                 \n                  sd_database(pause = TRUE)                                                                                 \n                \n                \n                                       \n                  Conditionally display questions                                     \n                  sd_config(show_if = XXX) & sd_config(show_if_custom = XXX)                                   \n                \n                \n                                       \n                  Conditionally skip to pages                                        \n                  sd_config(skip_if = XXX) & sd_config(skip_if_custom = XXX)                                   \n                \n                \n                                       \n                  Start survey from a specific page (helpful when editing)                  \n                  sd_config(start_page = \"page_id\")                                                                         \n                \n                \n                                       \n                  Show all pages at once (helpful for editing or printing out whole survey)\n                  sd_config(show_all_pages = TRUE)                                                                          \n                \n                \n                                       \n                  Require specific questions be answered                               \n                  sd_config(required_questions = c(\"question_1\", \"question_2\"))                                             \n                \n                \n                                       \n                  Require all questions be answered                                    \n                  sd_config(all_questions_required = TRUE)                                                                  \n                \n                \n                                       \n                  Time stamps recorded for each question and page interaction                                                               \n                  Happens by default.                                                                                                    \n                \n                \n                                       \n                  Progress bar bar that updates on each question interaction              \n                  Happens by default.                                                                                                    \n                \n                \n                                       \n                  Customizable progress bar color                                         \n                  In the YAML header, type:barcolor = \"A_HEX_COLOR\"                                                     \n                \n                \n                                       \n                  Customizable progress bar position                                      \n                  In the YAML header, type:barposition = \"top\", \"bottom\", or \"none\"           \n                \n                \n                                       \n                  Markdown formatting for options and buttons                             \n                  Just use markdown on options and buttons.                                                                              \n                \n                \n                                       \n                  Customizable scss theme file                                                                                              \n                  Use theme = custom.scss in the YAML header and put a custom.scss file in the project folder. \n                \n                \n                  \n                  Admin page with password login to preview / download data, pause survey, etc.     \n                  sd_config(admin_page = TRUE), then access with url, e.g. https://mysurvey.shinyapps.io/?admin\n                \n                \n                  \n                  Form validation (limit input based on question type)                                                                      \n                  Happens by default                                                                                                     \n                \n                \n                  \n                  Cookies to store user progress                                                                                            \n                  Happens by default                                                                                                     \n                \n                \n                  \n                  User tracking via url parameters                                                                                          \n                  By inputting the url parameters the users can go to the desired page                                                   \n                \n        \n      \n    \n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Documentation"
    ]
  },
  {
    "objectID": "demos.html",
    "href": "demos.html",
    "title": "Demos",
    "section": "",
    "text": "Question Types\nA demo of all the question types currently supported by surveydown.\n\n\n  \n\n\n\n\n\n\n\nConditional Display\nA demo of how to implement conditional display (showing a question based on a previous response).\n\n\n  \n\n\n\n\n\n\n\nConditional Skipping\nA demo of how to implement conditional skipping (skipping to a page based on a previous response).\n\n\n  \n\n\n\n\n\n\n\nRandomized Question Labels\nA demo of how to implement randomized question labels.\n\n\n  \n\n\n\n\n\n\n\nRandomized Question Labels (Predefined)\nA demo of how to implement randomized question labels using predefined random labels.\n\n\n  \n\n\n\n\n\n\n\nReactive Plot\nA demo of how to implement reactive plots in your survey.\n\n\n  \n\n\n\n\n\n\n\nChoice-Based Conjoint\nA demo of how to implement a choice-based conjoint survey with surveydown.\n\n\n  \n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Overview",
    "section": "",
    "text": "Overview\nsurveydown is a flexible, open-source platform for making surveys with , Quarto, Shiny, and Supabase. The accompanying  package is still in development, but you can already use it to create surveys!\n\n\n\n\n\nThe basic concept is this:\n\nDesign your survey as a Quarto Shiny document using markdown and R code.\nRender your doc into a Shiny app that can be hosted online and sent to respondents.\nStore your survey responses in a Supabase database.\n\nWe recommend reading the Get Started page to get a sense of how to use surveydown. The rest of the documentation covers more details on how to use surveydown.\n\nGet Started!\n\n\n\nEditing a surveydown survey\nEditing a surveydown survey feels like editing a Quarto document. As a result, we recommend working with an IDE to edit your surveys as they offer a better experience. RStudio is great, and we also like VS Code and Positron.\nOnce you have a survey ready to edit in your favorite IDE, you can render it locally to see how it will look as you change features. For example, the gif below shows what it looks like to make a question required. This gives you an idea for what the development process is like. And because surveydown leverages Shiny and Quarto, you can add all sorts of custom features and styles to your survey!\n\n\n\n\n\nBackground & Motivation\nMost survey platforms (e.g., Google forms, Qualtrics, etc.) use drag-and-drop interfaces to design surveys, making version control and collaboration with others difficult. They’re also not reproducible (others cannot easily reproduce a survey made on these platforms), and many require a paid subscription or license to use.\nAs an open-source, markdown-based platform, surveydown was designed to address these problems. In surveydown, all survey content is created with plain text (markdown and R code) in a single .qmd file that renders into a Shiny app. This makes your survey easy to reproduce, share, and version control with common tools like Git. The survey data collected is also owned by the survey designer in a Supabase account. Best of all, everything is open source and free :)\nIf you’re curious where this whole idea came from, check out this blog post, which outlines more on the general idea and the motivation for it. The post is now outdated in terms of the overall package design, but it provides something of an origin story and some of the motivation for developing this project.\n\n\nAuthors\nThe surveydown project is led by professor John Paul Helveston at George Washington University. The development team consists of the following members:\n\n\n\n\n\nJohn Paul Helveston, Ph.D.\nJohn Paul Helveston is an Assistant Professor in the Department of Engineering Management and Systems Engineering at George Washington University. Professor Helveston is the core designer and developer, and maintainer of both the surveydown project and this documentation website.\n\n\n\n\n\n\n\nPingfan Hu\nPingfan Hu is a Ph.D. student in Systems Engineering at George Washington University, supervised by professor Helveston. Pingfan is mainly responsible for UI design, user interactions, and website maintenance.\n\n\n\n\n\n\n\nBogdan Bunea\nBogdan Bunea is an undergraduate student majoring in Systems Engineering and minoring in Computer Science at George Washington University. Bogdan is mainly responsible for database connection and data management.\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "password.html",
    "href": "password.html",
    "title": "Setting Your Password",
    "section": "",
    "text": "Note\n\n\n\nTo avoid confusion, you need to deal with password both on Supabase and surveydown. Firstly, Supabase is where your password is defined (see Store Data for details). Then, on surveydown, you deliver this password using sd_set_password().",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Password"
    ]
  },
  {
    "objectID": "password.html#setting-your-project-password",
    "href": "password.html#setting-your-project-password",
    "title": "Setting Your Password",
    "section": "Setting your project password",
    "text": "Setting your project password\nTo set your surveydown password in a given project, run:\n\nsd_set_password(\"your_password\")\n\n\n\n\n\n\n\nImportant\n\n\n\nDo NOT put the sd_set_password() function in your .qmd file!\n\n\nThis is designed to be run once in your R console and not again (unless you want to change the password).",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Password"
    ]
  },
  {
    "objectID": "password.html#what-does-this-do",
    "href": "password.html#what-does-this-do",
    "title": "Setting Your Password",
    "section": "What does this do?",
    "text": "What does this do?\nBy running sd_set_password(), a .Renviron file is created in your project directory that contains your password. This file is used to access your database and write data to it, as well as provide access to the admin page. This file must remain in the root project directory - do not modify it.\nThe call to sd_set_password() also adds a .gitignore file in your project with .Renviron in it, so it won’t be accidentally pushed to GitHub. If a .gitignore file already exists, it will be updated to include .Renviron.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Password"
    ]
  },
  {
    "objectID": "password.html#what-is-the-password-used-for",
    "href": "password.html#what-is-the-password-used-for",
    "title": "Setting Your Password",
    "section": "What is the password used for?",
    "text": "What is the password used for?\nYour password is used for two purposes:\n\nObtaining access to the admin page of your survey.\nObtaining access to the Supabase database storing your survey data (see Store Data).\n\n\n\n\n\n\n\nImportant\n\n\n\nBe sure to use the same password when setting up your Supabase database.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Password"
    ]
  },
  {
    "objectID": "password.html#forgot-your-password",
    "href": "password.html#forgot-your-password",
    "title": "Setting Your Password",
    "section": "Forgot your password?",
    "text": "Forgot your password?\nTo reveal your password, run:\n\nsd_show_password()\n\n\n\n\n\n\n\nImportant\n\n\n\nThis is a one-time operation, so you can also run in your R console instead of the .qmd file. You will be prompted to confirm you really want to reveal your password, since it is a sensitive operation.\nIn short: SECURE YOUR PASSWORD!",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Password"
    ]
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Blog",
    "section": "",
    "text": "Choice-based conjoint surveys in R with surveydown\n\n\n\n\n\nA how-to guide for using R to design and implement choice-based conjoint surveys using the surveydown R package \n\n\n\n\n\n2024-08-28\n\n\nJohn Paul Helveston\n\n\n\n\n\n\n\n\n\n\n\n\nIntroducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny\n\n\n\n\n\nA quick overview of the {surveydown} R package for making markdown-based surveys with open-source technologies: Quarto, shiny, and supabase. \n\n\n\n\n\n2024-08-21\n\n\nJohn Paul Helveston\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "faq.html",
    "href": "faq.html",
    "title": "Frequently Asked Questions",
    "section": "",
    "text": "Use the required_questions argument in sd_config() to control required responses. See making a question required."
  },
  {
    "objectID": "faq.html#how-do-i-make-a-question-required",
    "href": "faq.html#how-do-i-make-a-question-required",
    "title": "Frequently Asked Questions",
    "section": "",
    "text": "Use the required_questions argument in sd_config() to control required responses. See making a question required."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to surveydown.org!",
    "section": "",
    "text": "Welcome to surveydown.org!\nsurveydown is a flexible, open-source platform for making surveys with , Quarto, Shiny, and Supabase. The accompanying  package is still in development, but you can already use it to create surveys!\n\n\n\n\n\nAbout the package and the open-source technologies behind it.\n\n\nABOUT\n\n\n\n\n\n\n\n\nDemos showcasing surveydown features.\n\n\nDEMOS\n\n\n\n\n\n\n\n\nDocumentation for building surveys with surveydown.\n\n\nDOCUMENTATION\n\n\n\n\n\n\n\n\nFrequently asked questions.\n\n\nFAQ\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "tips.html",
    "href": "tips.html",
    "title": "Tips",
    "section": "",
    "text": "This page has some helpful suggestions for working with surveydown surveys.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Tips"
    ]
  },
  {
    "objectID": "tips.html#splitting-the-server-chunk-into-a-separate-file",
    "href": "tips.html#splitting-the-server-chunk-into-a-separate-file",
    "title": "Tips",
    "section": "Splitting the server chunk into a separate file",
    "text": "Splitting the server chunk into a separate file\nThe server chunk contains many components:\n\nThe database setup via sd_database(), which defines your Supabase connection.\nAny configuration options via sd_config(), such as conditional show logic, skip logic, required questions, etc.\nAny other code, such as reactive questions (sd_question(reactive = TRUE)), other variables you wish to store in your database, etc.\n\nAs your survey grows in length and complexity, the server chunk can get quite long, and scrolling up and down to edit it along with the main survey content can be annoying. To address this, it can be helpful to split up your server code into a separate file so that you can open it in a separate tab in your editor.\nTo enable this, create a server.R file (can be any name you wish) in your project directory, and put all of your server code in this file except for the call to sd_server(). Then you can source the file into the server chunk like this:\n\n```{r}\n#| context: server\n\nsource(\"server.R\")\n\nsd_server(\n  input   = input,\n  output  = output,\n  session = session,\n  config  = config,\n  db      = db\n)\n```\n\nWith this setup, your server code chunk will remain unchanged and you will only need to edit your server.R file to customize your server settings.\n\n\n\n\n\n\nImportant\n\n\n\nNote that you still need to include the sd_server() function in your server code chunk after sourcing the server.R file.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Tips"
    ]
  },
  {
    "objectID": "fetch-data.html",
    "href": "fetch-data.html",
    "title": "Fetching Data",
    "section": "",
    "text": "Once you have your database properly set up and your survey is live, you can fetch the data using the sd_get_data() function. All you have to do is pass in the db object you created with sd_database() to the sd_get_data() function.\nFor example, if you have a table called my_table in your Supabase database, you can fetch the data like this:\n\nlibrary(surveydown)\n\ndb &lt;- sd_database(\n  user   = 'postgres.axzkymswaxcasjdflkurrj',\n  host   = 'aws-0-us-east-1.pooler.supabase.com',\n  port   = 5678,\n  db_name = 'postgres',\n  table_name = 'my_table'\n)\n\ndata &lt;- sd_get_data(db)\n\nHere the data object will be a data.frame with the data from your database.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Fetch Data"
    ]
  },
  {
    "objectID": "fetch-data.html#static-fetching",
    "href": "fetch-data.html#static-fetching",
    "title": "Fetching Data",
    "section": "",
    "text": "Once you have your database properly set up and your survey is live, you can fetch the data using the sd_get_data() function. All you have to do is pass in the db object you created with sd_database() to the sd_get_data() function.\nFor example, if you have a table called my_table in your Supabase database, you can fetch the data like this:\n\nlibrary(surveydown)\n\ndb &lt;- sd_database(\n  user   = 'postgres.axzkymswaxcasjdflkurrj',\n  host   = 'aws-0-us-east-1.pooler.supabase.com',\n  port   = 5678,\n  db_name = 'postgres',\n  table_name = 'my_table'\n)\n\ndata &lt;- sd_get_data(db)\n\nHere the data object will be a data.frame with the data from your database.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Fetch Data"
    ]
  },
  {
    "objectID": "fetch-data.html#reactive-fetching",
    "href": "fetch-data.html#reactive-fetching",
    "title": "Fetching Data",
    "section": "Reactive Fetching",
    "text": "Reactive Fetching\nThe above example is intended for an analysis context, where all you want to do is fetch the latest data from your database. However, you may also want to fetch the data in a reactive context (i.e. in your survey). For example, perhaps you want to show respondents a bar chart of the most common responses to a question. To enable this, all you have to do is set reactive = TRUE in the sd_get_data() function:\n\ndata &lt;- sd_get_data(db, reactive = TRUE)\n\nNow the data object will be a reactive expression, not a data.frame.\n\n\n\n\n\n\nImportant\n\n\n\nThe reactive = TRUE feature must be used in the server code chunk of your survey. Placing this anywhere else (e.g. a code chunk in the main part of your survey) will result in an error.\n\n\nTo use it, you have to call it with () to get the latest data as a data.frame. For example:\n\ndata &lt;- sd_get_data(db, reactive = TRUE)\n\noutput$my_plot &lt;- renderPlot({  \n  my_data &lt;- data()\n  # insert code here to make a plot with my_data\n})\n\nHere the my_data object will be a data.frame with the latest data from your database, which you could then use to make a plot. In this example, the output$my_plot object will be a plot, which you can then display in your survey by placing plotOutput(\"my_plot\") in a code chunk (or inline code) somewhere in your survey.\nSee the Reactivity page for more information on how to use reactivity in your survey.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Fetch Data"
    ]
  },
  {
    "objectID": "store-data.html",
    "href": "store-data.html",
    "title": "Storing Data",
    "section": "",
    "text": "The default database for storing survey responses is Supabase. We plan to also support the ability to use your own database in the future.\nBelow are the steps you need to go through on Supabase:\nWe’ll walk you through one by one.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Store Data"
    ]
  },
  {
    "objectID": "store-data.html#create-a-supabase-account",
    "href": "store-data.html#create-a-supabase-account",
    "title": "Storing Data",
    "section": "1. Create a Supabase account",
    "text": "1. Create a Supabase account\nNavigate to the Supabase website and create an account. You may use your GitHub account or create a new account using your email.\nWhile creating your account, it’s by default that you will have an organization under your account name. Your projects will be designated to this organization. You can have other organizations based on your need, but let’s just use this default one for now.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Store Data"
    ]
  },
  {
    "objectID": "store-data.html#create-a-supabase-project",
    "href": "store-data.html#create-a-supabase-project",
    "title": "Storing Data",
    "section": "2. Create a Supabase project",
    "text": "2. Create a Supabase project\nOnce you are logged in, the page will prompt you to create a project. It’s an obvious green button. Click on it and select your organization. A dialog box will pop up like this:\n\n\n\n\nFill in the project name and give it a strong password. Choose a region that is close to you (or close to your audiences). All settings can be modified at any time.\n\n\n\n\n\n\nTip\n\n\n\nTo avoid confusion, you need to deal with password both on Supabase and surveydown:\n\nSupabase is where your password is defined. Set your password in this dialog box, or change it in project settings anytime.\nOn surveydown, you deliver this password using sd_set_password().\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nYour database password will be used in your surveydown survey(s) as credential to communicate with Supabase, and will also be your surveydown survey admin page password. Please choose a strong password and secure it.\nTo know more about setting the password for your surveydown survey, go to the Password page.\n\n\nIt takes several minutes to set up the database. You will know when it’s ready.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Store Data"
    ]
  },
  {
    "objectID": "store-data.html#copy-your-credentials",
    "href": "store-data.html#copy-your-credentials",
    "title": "Storing Data",
    "section": "3: Copy your credentials",
    "text": "3: Copy your credentials\nOnce your Supabase project is ready, go to “Project Settings” located at the bottom-left corner. Then, click on “Database” under “Configuration”.\nYou’ll see the “Connection parameters” section like this:\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThis is also where you change the password of your Supabase project.\n\n\nNow, deliver these parameters to your survey! In your survey .qmd file, you define sd_database() at the very bottom. In the template it looks like this:\n\ndb &lt;- sd_database(\n  host   = NULL,\n  dbname = NULL,\n  port   = NULL,\n  user   = NULL,\n  table  = NULL\n)\n\nCopy and paste the first 4 parameters from your Supabase page to sd_database(), aka “Host”, “Database name”, “Port”, and “User”. Again, your password should be defined using sd_set_password() in your R console, NOT in the .qmd file.\nThe last parameter, table, can be anything of your choice. After your survey gets running, a table with this name will appear in “Table Editor” of your Supabase project. It’s located at the top-left corner of the page.\n\n\n\n\n\n\nTip\n\n\n\nRun without Supabase:\nIf you don’t have a database setup yet, you can just leave the function blank and your survey will still run. Your survey data will be stored locally.\n\ndb &lt;- sd_database()\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nPause Supabase connection:\nAt anytime, you can pause Supabase connection by defining pause = TRUE under sd_database(). Your survey data will be stored locally.\n\ndb &lt;- sd_database(\n    # Previous parameters...\n    pause = TRUE\n)\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nDisable gssencmode:\nIf you’ve set everything correctly but still encounter connection error, try to disable gssencmode:\n\ndb &lt;- sd_database(\n    # Previous parameters...\n    gssencmode = \"disable\"\n)\n\nBy default, gssencmode is set as \"prefer\". It secures your connection with PostgreSQL, which is the SQL used by Supabase. We generally recommend that you DON’T disable gssencmode.\n\n\nNow you have completed your database settings. Once your survey is up and running, you can monitor the survey responses in “Table Editor” of your Supabase project. Again it’s located at the top-left corner of the page. The responses will update in real time, or you can refresh it manually.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Store Data"
    ]
  },
  {
    "objectID": "deployment.html",
    "href": "deployment.html",
    "title": "Deploying Your Survey",
    "section": "",
    "text": "Once you have previewed and tested your survey and are ready to field it, it is time to make it live for respondents to fill out.\nTo deploy your survey, you’ll need to have the following recipes ready:\nThese steps are easy to follow. We will go through one by one.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Deployment"
    ]
  },
  {
    "objectID": "deployment.html#demo-survey",
    "href": "deployment.html#demo-survey",
    "title": "Deploying Your Survey",
    "section": "Demo Survey",
    "text": "Demo Survey\nIf you have trouble constructing your own survey, we have prepared a demo survey:\n\nOnline demo survey\nGitHub repository\n\nThis survey was made on RStudio using the {surveydown} R package and the surveydown Quarto extension, with survey data stored on Supabase, and its online website deployed on shinyapps.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Deployment"
    ]
  },
  {
    "objectID": "deployment.html#step-1-survey-project",
    "href": "deployment.html#step-1-survey-project",
    "title": "Deploying Your Survey",
    "section": "Step 1: Survey Project",
    "text": "Step 1: Survey Project\n\nStep 1-1: Construct your survey\nConstruct your survey using the {surveydown} R package and the surveydown Quarto extension.\nThe previous articles in Usage Guide are sufficient to guide you through the survey construction process.\n\n\nStep 1-2: Set your password\nOne important setting is the password of your Supabase project. Here’s how.\nWhile you set up your Supabase project, you will create a password for it. This password will then be defined in your survey project. In the very end of your survey .qmd file, you’ll need to define the db variable, which should be the settings of your Supabase project. There is an argument called password. You can directly paste your password here as password = \"my_password\", but it’s not recommended since this will make your Supabase project unsafe.\nWe recommend you to write password = Sys.getenv(\"SUPABASE_PASSWORD\"), like this:\n\ndb &lt;- sd_database(\n  # Other settings...\n  password = Sys.getenv(\"SUPABASE_PASSWORD\")\n)\n\nThen, define the password using the sd_set_password() function. For example, if your password is my_password, you should run sd_set_password(\"my_password\") in the R Console.\nGreat! Now you have your Supabase password successfully defined in your survey project!\nIf you are interested, below are the details of what sd_set_password() does:\n\nIt creates an .Renviron file or writes into an existing one.\nIn this .Renviron file, it writes in SUPABASE_PASSWORD=my_password, where \"my_password\" is whatever your argument of the sd_set_password() function.\nIf there is a previously defined SUPABASE_PASSWORD in .Renviron, it will be overwritten, so you are safe to run this function multiple times.\nIt adds .Renviron into .gitignore to avoid it being pushed to GitHub thus keeps your password safe. If you run multiple times, .Renviron will appear only once in .gitignore.\n\n\n\nStep 1-3: Render your .qmd file\nThis is simple: just hit Render or cmd/ctrl + shift + K (Mac/Win). But the reason why I make this a stand-alone step is that, WITHOUT rendering your .qmd file, your survey CANNOT be deployed online.\nOne more thing… If you fail to deploy locally while you have set every argument correctly in your db variable, try to define gssencmode = \"disable\" in your db variable:\n\ndb &lt;- sd_database(\n  # Other settings...\n  gssencmode = \"disable\"\n)\n\nThis can help solve your connection problem. The value of gssencmode is set to \"prefer\" by default.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Deployment"
    ]
  },
  {
    "objectID": "deployment.html#step-2-supabase-project",
    "href": "deployment.html#step-2-supabase-project",
    "title": "Deploying Your Survey",
    "section": "Step 2: Supabase Project",
    "text": "Step 2: Supabase Project\nThis is covered in Store Data. I want to further mention that you don’t need to actively create any table on your Supabase project. In your db variable of your .qmd file, there is a table_name argument. Whatever name you define here will become the table name of your Supabase:\n\ndb &lt;- sd_database(\n  # Other settings...\n  table_name = \"demo\"\n)\n\nIn the above example, the table name in my Supabase project will be \"demo\". If your survey project runs successfully locally and can have survey data collected in Supabase, you are ready for your online deployment.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Deployment"
    ]
  },
  {
    "objectID": "deployment.html#step-3-online-deployment",
    "href": "deployment.html#step-3-online-deployment",
    "title": "Deploying Your Survey",
    "section": "Step 3: Online Deployment",
    "text": "Step 3: Online Deployment\nSo this is our final step: to deploy your survey online. I’m glad you’ve made this far! You are almost there!\nWe’ll use shinyapps.io. Now before we start, here are two explanations to clear out your possible questions:\n\nshinyapps.io can support both Shiny Apps and Quarto Shiny Documents. In our case, our survey is considered as a Quarto Shiny Document.\nQuarto Pub is also a website publishing platform. In fact, both Quarto Pub and shinyapps.io are provided by Posit. However, we DON’T use Quarto Pub for our survey deployment. The core reason is that, shinyapps.io can make interactive websites, but Quarto Pub only makes static websites. A survey is apparently an interactive website, so it’s compatible with shinyapps.io, not Quarto Pub.\n\nTo start using shinyapps.io, you’ll need to create an account and follow the basic instructions to set up your sub-domain and authorize your IDE. See more information here.\nOnce you have your account and your sub-domain ready, it’s time to deploy your survey website.\nMake sure you have the rsconnect R package installed (You should have done this while you authorize your IDE):\n\ninstall.packages('rsconnect')\n\nThe simplest way is to run this:\n\nrsconnect::deployDoc(\"your_survey.qmd\")\n\nThe URL of this page will be your domain followed by /your_survey, which means the name of your .qmd file will be in the URL. The tab name of the HTML page is also your_survey. Better give a good name to your .qmd file.\nAgain, you’ll need to firstly render locally and make sure it works properly. Otherwise, this deployment will fail.\nIf you want to define a different tab name for your survey page, run:\n\nrsconnect::deployDoc(\n  doc = \"your_survey.qmd\",\n  appName = \"Survey Name\"\n)\n\nNow you should have your survey site deployed. The survey is now served on shinyapps.io, with its data stored on Supabase. Congratulations!\nFurther explanation (with my personal interpretation) of the deployment functions:\nIn rsconnect, there are two functions that can be used for deployment: deployApp() and deployDoc(). They serve different purposes and should NOT be mix-used.\n\ndeployApp() is used to deploy a Shiny App. It doesn’t work for .qmd, but works for Shiny App and .rmd, and it accepts multiple files.\ndeployDoc() is used to deploy a Quarto Shiny Document. It works for a single file and tries to “automatically discover dependencies” (direct paste from official instructions).\nSince our survey is a Quarto Shiny Document, we use deployDoc().\n\n\nI guess deployDoc() is a newer function that specifically works for .qmd. I have a feeling that this function is specifically made for .qmd to match the fact of “single document” and “dependencies”. In our case, deployDoc() is a perfect match.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Deployment"
    ]
  },
  {
    "objectID": "get-started.html",
    "href": "get-started.html",
    "title": "Getting Started",
    "section": "",
    "text": "In surveydown, surveys are designed using markdown and R code in a single Quarto document (a .qmd file). There is no GUI or drag-and-drop interface - simply write plain text (markdown & R code) and boom - you have a survey! 🎉\nThe {surveydown} R package provides a set of functions for defining the survey content and configuration options. Each function starts with sd_ to make them easy to identify.\nThe platform is based on some basic principles:\n\nAdd content to your survey using markdown text (or in RStudio use the visual editor).\nDefine survey questions in R code chunks with the sd_question() function.\nDefine pages using fences (:::), with navigation buttons handled using the sd_next() function.\nAdd rich functionality to your survey using config options in the server code chunk.\nStore your respondent data on Supabase by setting the database in the server code chunk.\n\nThis approach ensures a flexible survey platform that is fully reproducible and easy to customize.\nThe remaining steps on this page will guide you through the process of creating a surveydown survey.",
    "crumbs": [
      "Documentation",
      "Get Started"
    ]
  },
  {
    "objectID": "get-started.html#overview",
    "href": "get-started.html#overview",
    "title": "Getting Started",
    "section": "",
    "text": "In surveydown, surveys are designed using markdown and R code in a single Quarto document (a .qmd file). There is no GUI or drag-and-drop interface - simply write plain text (markdown & R code) and boom - you have a survey! 🎉\nThe {surveydown} R package provides a set of functions for defining the survey content and configuration options. Each function starts with sd_ to make them easy to identify.\nThe platform is based on some basic principles:\n\nAdd content to your survey using markdown text (or in RStudio use the visual editor).\nDefine survey questions in R code chunks with the sd_question() function.\nDefine pages using fences (:::), with navigation buttons handled using the sd_next() function.\nAdd rich functionality to your survey using config options in the server code chunk.\nStore your respondent data on Supabase by setting the database in the server code chunk.\n\nThis approach ensures a flexible survey platform that is fully reproducible and easy to customize.\nThe remaining steps on this page will guide you through the process of creating a surveydown survey.",
    "crumbs": [
      "Documentation",
      "Get Started"
    ]
  },
  {
    "objectID": "get-started.html#install",
    "href": "get-started.html#install",
    "title": "Getting Started",
    "section": "1. Install",
    "text": "1. Install\nSee the Installation page.",
    "crumbs": [
      "Documentation",
      "Get Started"
    ]
  },
  {
    "objectID": "get-started.html#start-with-a-template",
    "href": "get-started.html#start-with-a-template",
    "title": "Getting Started",
    "section": "2. Start with a template",
    "text": "2. Start with a template\nIn the R console, run the following to to setup a template survey:\n\nsurveydown::sd_create_survey(\"path/to/folder\")\n\nThis will create a folder located at \"path/to/folder\" with the following files:\n\nexample.qmd: a template survey you should edit.\nexample.Rproj: An RStudio project file (helpful if you’re working in RStudio)\n_extensions: A folder with the surveydown Quarto extension needed to make everything work (don’t modify this).\n\n\n\n\n\n\n\nImportant\n\n\n\nEvery survey created with {surveydown} should be in its own separate project folder.",
    "crumbs": [
      "Documentation",
      "Get Started"
    ]
  },
  {
    "objectID": "get-started.html#add-content",
    "href": "get-started.html#add-content",
    "title": "Getting Started",
    "section": "3. Add content",
    "text": "3. Add content\nSee the Survey Components page for details on the main components in a surveydown survey. For a quick overview, here’s how you add pages and questions:\n\nAdd pages with fences, like this:\n\n\n::: {#page1 .sd-page}\n\nPage 1 content here\n\n:::\n\n\nAdd questions with the sd_question() function in code chunks (see the Question Types page for more on the types of questions supported). For example, here’s a multiple choice question:\n\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n```\n\nOutput:\n\n\n\n\nWhich is your favorite type of penguin? *\n\n\n\n\n\nAdélie\n\n\n\n\n\nChinstrap\n\n\n\n\n\nGentoo",
    "crumbs": [
      "Documentation",
      "Get Started"
    ]
  },
  {
    "objectID": "get-started.html#add-configuration-options",
    "href": "get-started.html#add-configuration-options",
    "title": "Getting Started",
    "section": "4. Add configuration options",
    "text": "4. Add configuration options\nIn the server chunk (bottom of the .qmd file), add control logic and other configuration options to your survey with the sd_config() function. See the Configuration Options page for more details.",
    "crumbs": [
      "Documentation",
      "Get Started"
    ]
  },
  {
    "objectID": "get-started.html#setup-your-database",
    "href": "get-started.html#setup-your-database",
    "title": "Getting Started",
    "section": "5. Setup your database",
    "text": "5. Setup your database\nAlso in the server chunk, setup your database with the sd_database() function. You can also leave it blank to preview / edit your survey without database connected, or set pause = TRUE to disconnect the survey. See the Store Data page for more details.",
    "crumbs": [
      "Documentation",
      "Get Started"
    ]
  },
  {
    "objectID": "get-started.html#locally-preview",
    "href": "get-started.html#locally-preview",
    "title": "Getting Started",
    "section": "6. Locally preview",
    "text": "6. Locally preview\nPreview your survey by clicking the “Run Document” button in RStudio or in your terminal running the command:\n\nquarto serve survey_file_name.qmd\n\nReplacing survey_file_name.qmd with the name of your survey .qmd file.",
    "crumbs": [
      "Documentation",
      "Get Started"
    ]
  },
  {
    "objectID": "get-started.html#deploy",
    "href": "get-started.html#deploy",
    "title": "Getting Started",
    "section": "7. Deploy",
    "text": "7. Deploy\nDeploy your survey by hosting it on your favorite server, like shinyapps.io, huggingface, etc. See the Deployment page for more details.",
    "crumbs": [
      "Documentation",
      "Get Started"
    ]
  },
  {
    "objectID": "config-options.html",
    "href": "config-options.html",
    "title": "Configuration Options",
    "section": "",
    "text": "All survey configuration options are defined with the sd_config() function in the server code chunk.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Config Options"
    ]
  },
  {
    "objectID": "config-options.html#conditional-display",
    "href": "config-options.html#conditional-display",
    "title": "Configuration Options",
    "section": "Conditional display",
    "text": "Conditional display\n\nBasic conditional display\n\n\n\n\n\n\nTip\n\n\n\nUse the show_if argument to control basic conditional display logic.\n\n\nIt is often useful to have a question display conditionally based on the value of another question. For example, let’s say we have a multiple choice question about people’s favorite penguin type, and the last option is “other”. If the respondent chose it, you may want a second question to popup that allows them to specify the other penguin type, like this:\n\n\n\n\nTo implement this, you first need to define both the triggering question and the target question, like this:\n\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo',\n    'Other'     = 'other'\n  )\n)\n\nsd_question(\n  type  = \"text\",\n  id    = \"penguins_other\",\n  label = \"Please specify the other penguin type:\"\n)\n\nThen in the server code chunk, you can use the show_if argument to define that the penguins_other question would only be shown if the respondent chose the other option in the penguins question, like this:\n\nconfig &lt;- sd_config(\n  show_if = tibble::tribble(\n    ~question_id,  ~question_value, ~target,\n    \"penguins\",    \"other\",         \"penguins_other\"\n  )\n)\n\nHere we’re using the tibble::tribble() function (which is like data.frame() but easier to read), to define a data frame with three columns:\n\nquestion_id: The id of the triggering question.\nquestion_value: The triggering value.\ntarget: The id of the target question to display.\n\nEach row in the data frame defines a condition.\nYou don’t have to use tibble::tribble(), and in fact if you have a lot of show_if conditions, then you could create a csv file with all of your conditions in it and read it in to set the show_if conditions (just make sure the header has the same three column names), e.g.:\n\nconfig &lt;- sd_config(\n  show_if = readr::read_csv('path/to/show_if_conditions.csv')\n  )\n\n\n\nCustom conditional display\n\n\n\n\n\n\nTip\n\n\n\nUse the show_if_custom argument to control custom conditional display logic.\n\n\nThe standard show_if argument is great for simple conditional display logic, but sometimes you need more flexibility. For example, you may want to display a question based on the values of two different questions. In this case, you can use the show_if_custom argument to define a custom function that determines the conditions for displaying a target question.\nUsing the same example as above, let’s say we only want to display the penguins_other question if the respondent chose the other option in the penguins question and also if they chose show in a second question, show_other:\n\nsd_question(\n  type  = 'mc',\n  id    = 'show_other',\n  label = \"Should we show the 'other' option question?\",\n  option = c(\n    'Show' = 'show',\n    'Hide' = 'hide'\n  )\n)\n\nNow we can define a custom function that will check the values of the penguins and show_other questions and return a logical value indicating whether both conditions are met. Then we can use this function in the show_if_custom argument:\n\nshow_other &lt;- function(input) {\n  return(input$penguins == \"other\" & input$show_other == \"show\")\n}\n\nconfig &lt;- sd_config(\n  show_if_custom = list(\n    list(condition = show_other, target = \"penguins_other\")\n  )\n)\n\nHere we provided the show_if_custom argument a list of lists, where each sublist contains a condition and a target. In this example, we just have one condition (the show_other function, which if true will display the penguins_other question), but you can add as many conditions as you want.\nIf lists of lists are a little confusing, you can also use a tibble::tribble() to define the conditions, like this:\n\nconfig &lt;- sd_config(\n  show_if_custom = tibble::tribble(\n    ~condition, ~target,\n    show_other, \"penguins_other\"\n  )\n)\n\nIn this case, each row in the tibble() is a condition with each condition in the condition column and the target question to display in the target column. This layout is sometimes a little easier to read, especially if you have a lot of conditions.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Config Options"
    ]
  },
  {
    "objectID": "config-options.html#conditional-skipping",
    "href": "config-options.html#conditional-skipping",
    "title": "Configuration Options",
    "section": "Conditional skipping",
    "text": "Conditional skipping\n\nBasic skipping\n\n\n\n\n\n\nTip\n\n\n\nUse the skip_if argument to control basic skipping logic.\n\n\nOften times you’ll want to send people to different parts of the survey based on responses to questions. For example, let’s say you want to screen out people who do not own a vehicle. To do this, you would first define a question about their vehicle ownership, e.g.:\n\nsd_question(\n  type  = 'mc',\n  id    = 'vehicle_ownership',\n  label = \"Do you own your vehicle?\",\n  option = c(\n    'Yes' = 'yes',\n    'No'  = 'no'\n  )\n)\n\nThen in the server code chunk, you can use the skip_if argument in sd_config() to define the behavior of the next button on the page where you ask this question, like this:\n\nconfig &lt;- sd_config(\n  skip_if = tibble::tribble(\n    ~question_id,        ~question_value, ~target,\n    \"vehicle_ownership\", \"no\",            \"screenout\"\n  )\n)\n\nThis sets up a condition where the respondent will be sent to a page named screenout if they choose no on the vehicle_ownership question. Notice that again we used tibble::tribble() to define the conditions, just as we did for the show_if argument in basic conditional display, but again you could use a csv file if you have a lot of conditions.\nIn this example, you could make a screenout page and put it anywhere in your survey after the vehicle_ownership question, something like this:\n\n::: {#screenout .sd-page}\n\nSorry, but you are not qualified to take our survey.\n\n:::\n\nNotice that we don’t have a sd_next() on this screenout page - that is how you define an end point for the survey taker. If there’s no “Next” button, then they cannot navigate anywhere else, so the survey is over. This is why this screenout page doesn’t necessarily have to be at the end of the survey as the respondent will not be able to navigate anywhere else once reaching this page.\n\n\nCustom skipping\n\n\n\n\n\n\nTip\n\n\n\nUse the skip_if_custom argument to control custom skipping logic.\n\n\nSimilar to the show_if_custom argument, the skip_if_custom argument allows you to define custom skipping logic. This is useful if you need to skip a question based on the values of two or more different questions (or other conditions).\nFor example, let’s say you want to screen out respondents only if they choose no on the vehicle_ownership question and no on a second question, vehicle_buyer:\n\nsd_question(\n  type  = 'mc',\n  id    = 'vehicle_buyer',\n  label = \"Are you looking to buy a vehicle soon?\",\n  option = c(\n    'Yes' = 'yes',\n    'No'  = 'no'\n  )\n)\n\nTo implement this, we can define a custom function that will check the values of the vehicle_ownership and vehicle_buyer questions and return a logical value indicating whether both conditions are met. Then we can use this function in the skip_if_custom argument:\n\nscreenout &lt;- function(input) {\n  return(input$vehicle_ownership == \"no\" & input$vehicle_buyer == \"no\")\n}\n\nconfig &lt;- sd_config(\n  skip_if_custom = list(\n    list(condition = screenout, target = \"screenout\")\n  )\n)\n\nJust as with the show_if_custom argument, we provide the skip_if_custom argument a list of lists, where each sublist contains a condition and a target.\nIf lists of lists are a little confusing, you can also use a tibble::tribble() to define the conditions, like this:\n\nconfig &lt;- sd_config(\n  skip_if_custom = tibble::tribble(\n    ~condition, ~target,\n    screenout, \"screenout\"\n  )\n)\n\nIn this case, each row in the tibble() is a condition with each condition in the condition column and the target question to display in the target column. This layout is sometimes a little easier to read, especially if you have a lot of conditions.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Config Options"
    ]
  },
  {
    "objectID": "config-options.html#required-responses",
    "href": "config-options.html#required-responses",
    "title": "Configuration Options",
    "section": "Required responses",
    "text": "Required responses\n\n\n\n\n\n\nTip\n\n\n\nUse the required_questions argument to control required responses.\n\n\nBy default, no questions are required. However, you can make questions required by adding the question id to the required_questions argument in sd_config(), like this:\n\nconfig &lt;- sd_config(\n  required_questions = c(\"vehicle_ownership\", \"penguins_other\")\n)\n\nThis will make the respondent unable to proceed until they have answered the required questions. It will also place a red asterisk (*) next to the question label to indicate that the question is required.\nYou can also make all questions required by setting all_questions_required = TRUE like this:\n\nconfig &lt;- sd_config(\n  all_questions_required = TRUE\n)",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Config Options"
    ]
  },
  {
    "objectID": "config-options.html#starting-page",
    "href": "config-options.html#starting-page",
    "title": "Configuration Options",
    "section": "Starting page",
    "text": "Starting page\n\n\n\n\n\n\nTip\n\n\n\nUse the start_page argument to control the starting page.\n\n\nWhen editing your survey, it can be helpful to start the survey at a specific page. You can define the starting page by setting the start_page argument to a page id in the sd_config() function, like this:\n\nconfig &lt;- sd_config(\n  start_page = \"page_id\"\n)",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Config Options"
    ]
  },
  {
    "objectID": "config-options.html#show-all-pages",
    "href": "config-options.html#show-all-pages",
    "title": "Configuration Options",
    "section": "Show all pages",
    "text": "Show all pages\n\n\n\n\n\n\nTip\n\n\n\nUse the show_all_pages argument to show al pages at once.\n\n\nBy setting show_all_pages = TRUE in the sd_config() function, all pages will be shown when the survey loads. This can be helpful for quickly previewing the survey content and / or printing out the entire survey as a PDF.\n\nconfig &lt;- sd_config(\n  show_all_pages = TRUE\n)",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Config Options"
    ]
  },
  {
    "objectID": "config-options.html#admin-page",
    "href": "config-options.html#admin-page",
    "title": "Configuration Options",
    "section": "Admin page",
    "text": "Admin page\n\n\n\n\n\n\nTip\n\n\n\nUse the admin_page argument to control whether the admin page is created.\n\n\nBy default, the admin page is not created. But if you want one, set admin_page to TRUE inside the sd_config() function, like this:\n\nconfig &lt;- sd_config(\n  admin_page = TRUE\n)\n\nWhen the admin page is enabled, you will be able to access the page by adding ?admin to the end of the survey URL, e.g. https://myname.shinyapps.io/?admin. This will display a login page with a single “Password” parameter, which is the password set using sd_set_password(). See the Password page for details.\nThe admin page has the following features:\n\nPause Survey: Once clicked, the Shiny app pauses all instances replacing questions with a placeholder “Paused Survey” page. Status: Non-functional\nPause DB: Once clicked, the pause argument set in sd_database() will be set to TRUE, pausing all database uploads. Status: Non-functional\nDownload Data: Once clicked, the most recent table instance is pulled from the database and downloaded locally as a .csv file.\nAdmin Logout and Return to Survey: Once clicked, the admin page will be logged out and the survey will be returned to the start page.\nSurvey Data: Pulls most recent instance of the database and displays the data.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Config Options"
    ]
  },
  {
    "objectID": "reactivity.html",
    "href": "reactivity.html",
    "title": "Reactivity",
    "section": "",
    "text": "Because surveydown renders to a Shiny app, it can take advantage of Shiny’s reactivity features. This means you can create reactive expressions and reactive values that update the survey in response to user input or other events.\nThis page demonstrates some common use cases for reactive programming in surveydown.",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Reactivity"
    ]
  },
  {
    "objectID": "reactivity.html#displaying-respondent-values",
    "href": "reactivity.html#displaying-respondent-values",
    "title": "Reactivity",
    "section": "Displaying respondent values",
    "text": "Displaying respondent values\n\nBasic example\nA simply example of a reactive value is displaying the respondent’s name in a greeting message. First, you would ask the respondent’s name in a question:\n\nsd_question(\n  type  = \"text\",\n  id    = \"name\",\n  label = \"What is your name?\"\n)\n\nThen you can use the sd_display_value() function to display the value of the \"name\" question in other parts of your survey. For example:\n\nWelcome, `r sd_display_value(\"name\")`!\n\nIf the respondent entered “Dave” in the name question, this would render as:\n\nWelcome, Dave!\n\nThis works because under the hood, the sd_display_value() function is calling a shiny output function, like shiny::textOutput(), which is designed to show reactive values (values that change based on a user input).\nYou could also use any shiny output function directly, like this:\n\nWelcome, `r shiny::textOutput(\"name\")`!\n\nWe just made sd_display_value() as it’s easier to use if you’re not sure which shiny output function to use.\n\n\nShowing the same value in multiple places\nThe sd_display_value() function can only be used once per each unique question id because the id gets used in the rendered HTML divs, and HTML with more than one element with the same id is invalid HTML. This is a general issue for Shiny - outputs can only be used once per each unique id (see this GitHub issue on the topic).\nThe solution that we use is to simply make a copy of the value and then display the copy (this is also the solution on the GitHub issue linked above).\nTo do so, in the server code chunk use the sd_copy_value() function to create a copy of the value, like this:\n\nsd_copy_value(id = \"name\", id_copy = \"name_copy\")\n\nYou can then use the sd_display_value() function to display both the original and copied values. For example:\n\nWelcome, `r sd_display_value(\"name\")`!\n\nIs it alright if we call you `r sd_display_value(\"name_copy\")`?",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Reactivity"
    ]
  },
  {
    "objectID": "reactivity.html#randomizing-question-labels",
    "href": "reactivity.html#randomizing-question-labels",
    "title": "Reactivity",
    "section": "Randomizing question labels",
    "text": "Randomizing question labels\nShowing a question with randomized labels is a common use case for reactive programming. There are at least two ways to achieve this.\n\nLive randomization\nOne approach is to generate the random labels in the server code chunk “live”, meaning that the labels will be generated when the survey is first loaded. For example, here I generate three random numbers between 1 and 100 and use them to create the option labels for a multiple choice question:\n\n# Create a vector of options\nq1_options &lt;- c('option 1', 'option 2', 'option 3')\n\n# Randomly sample 3 labels from 1 to 100\nq1_labels &lt;- sample(seq(100), 3) \n\n# Assign the labels to the options\nnames(q1_options) &lt;- q1_labels \n\nq1_options\n\n#&gt;         49         65         25 \n#&gt; \"option 1\" \"option 2\" \"option 3\"\n\n\nRemember that the names of the vector are the labels, so the respondents will see the numbers in the names of the above vector, and the values ('option1', etc.) will be stored in the resulting survey data.\nTo then use these options in a multiple choice question, you would use the sd_question() function with reactive = TRUE, like this:\n\nsd_question(\n  id = \"q1\",\n  type = \"mc\",  \n  label = \"Which of these numbers is the largest?\",\n  option = q1_options,\n  reactive = TRUE\n)\n\nThe key here is reactive = TRUE, which tells surveydown to make this a reactive question. By putting this question inside the server code chunk, the question will be created as a reactive question that can be displayed in the survey using the sd_display_question() function, like this:\n\n```{r}\nsd_display_question(id = \"q1\")\n```\n\nOne important caveat to this approach is that the random numbers that are generated are not automatically stored in the survey data (because they are generated live). If you needed to store the random numbers, you can use the sd_store_value() function, like this:\n\nsd_store_value(q1_labels, id = \"q1_labels\")\n\nThis would store the numbers in the q1_labels column of the survey data, which would be concatenated into the single string: 49, 65, 25.\nYou could alternatively use the sd_store_value() function to store each of the random numbers in separate columns, like this:\n\nsd_store_value(q1_labels[1], id = \"q1_label_1\")\nsd_store_value(q1_labels[2], id = \"q1_label_2\")\nsd_store_value(q1_labels[3], id = \"q1_label_3\")\n\n\n\nPre-defined randomization\nAn alternative approach is to pre-define the randomized labels and store them in a separate design file, and then randomly select a set of labels for each respondent from the design file.\nFor example, let’s generate 10 sets of 3 random numbers between 1 and 100 and store them in a data frame:\n\ndesign &lt;- data.frame(\n  id = rep(1:10, each = 3),\n  numbers = unlist(lapply(1:10, function(x) sample(seq(100), 3)))\n)\n\nhead(design)\n\n#&gt;   id numbers\n#&gt; 1  1      74\n#&gt; 2  1      18\n#&gt; 3  1      49\n#&gt; 4  2      47\n#&gt; 5  2      24\n#&gt; 6  2      71\n\n\nNow we can write this design to a csv file:\n\nreadr::write_csv(design, \"design.csv\")\n\nThen in your server code chunk, you could read in the design file and use it to randomize the labels for each question. Here the only thing you would need to keep track of the randomly chosen row id:\n\n# Read in the design file\ndesign &lt;- readr::read_csv(\"design.csv\")\n\n# Randomly choose a row id\nq1_id &lt;- sample(design$id, 1)\n\n# Store the chosen row id in the survey data (here q1_id will be the column name)\nsd_store_value(q1_id) \n\n# Filter the design to get the chosen row\nnumbers &lt;- design |&gt; \n  filter(id == q1_id) |&gt; \n  pull(numbers)\n\n# Create the options\nq1_options &lt;- c('option 1', 'option 2', 'option 3')\nnames(q1_options) &lt;- numbers\n\n# Create the reactive question\nsd_question(\n  id = \"q1\",\n  type = \"mc\",  \n  label = \"Which of these numbers is the largest?\",\n  option = q1_options,\n  reactive = TRUE\n)",
    "crumbs": [
      "Documentation",
      "Reference Manuals",
      "Reactivity"
    ]
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html",
    "href": "blog/2024-08-21-introducing-surveydown/index.html",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "",
    "text": "This post introduces the {surveydown} R package, a new way to design surveys using markdown, R, Quarto, and shiny. The idea for this platform has been brewing for a while (see this blog post for more on the motivation for this project), but now the package is finally here!\nIn this post, I’m going to show you a quick overview of the {surveydown} R package for making markdown-based surveys as well as a little about why we built surveydown."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#open-source",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#open-source",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Open source",
    "text": "Open source\nsurveydown is built entirely with open-source technologies, making it transparent and customizable. Best of all, no expensive licenses! Just install and use it!"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#own-your-data",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#own-your-data",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Own your data",
    "text": "Own your data\nWith surveydown, you retain full ownership and control of your survey data. The responses are stored in your own Supabase database, ensuring that you have complete access to the data. This is particularly important for researchers dealing with sensitive information or those who need to comply with specific data protection regulations. We’re still working on enabling you to use your own hosted database, which will provide even more flexibility."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#ease-of-editing",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#ease-of-editing",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Ease of editing",
    "text": "Ease of editing\nDesigning a survey in surveydown is a pretty straightforward process. The markdown-based approach allows for quick modifications and easy navigation through your survey. And since it’s built on Quarto, you can use all of the features of Quarto to make your survey look great, like changing the theme, adding custom CSS, etc. You can also easily preview your survey as you edit it, and even run your survey locally to test it out before you deploy it, either with a button click in RStudio or with a quarto serve command in the terminal."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#did-i-mention-you-can-run-r-code-in-your-survey",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#did-i-mention-you-can-run-r-code-in-your-survey",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Did I mention you can run R code in your survey?",
    "text": "Did I mention you can run R code in your survey?\nEvery surveydown survey uses R code chunks for questions. But you can also insert R code for all sorts of other things. For example, if you wanted to randomize the values shown in a question, you could write some R code for that. Want to insert a plot of something? Write a little ggplot code. You can also add interactive components to your surveys, such as showing a respondent how their responses compare to others in real time."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#easy-version-control-and-collaboration",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#easy-version-control-and-collaboration",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Easy version control and collaboration",
    "text": "Easy version control and collaboration\nBecause the entire survey is defined in a single plain text file, surveydown naturally integrates with version control systems like Git. This allows you to track changes over time, collaborate with team members, and maintain a clear history of your survey’s development."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#reproducible",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#reproducible",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Reproducible",
    "text": "Reproducible\nSurveydown promotes reproducible research by allowing you to define your entire survey in a single, self-contained plain text document. This has a ton of benefits:\n\nWant someone else to be able to reproduce your experiment? Just give them the .qmd file and any other files they need (e.g., images, data, etc.), and they can reproduce your survey on their own computer.\nWant to print out your survey for an appendix? Render the survey with all pages visible then print it to pdf.\nWant others to see your survey live? Just set the database into pause mode and your survey will function without recording any responses.\n\nReproducibility is something we had in mind from the start with this project, and we’ve tried to make it as easy as possible for your surveydown surveys to be fully reproducible."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#getting-started",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#getting-started",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Getting started",
    "text": "Getting started\nAfter getting everything installed, we recommend starting with a template survey project. To do so, run the following in the R console:\n\nsurveydown::sd_create_survey(\"path/to/folder\")\n\nThis will create a folder with the following files:\n\nexample.qmd: a template survey you should edit.\nexample.Rproj: An RStudio project file (helpful if you’re working in RStudio)\n_extensions: A folder with the surveydown Quarto extension needed to make everything work (don’t modify this).\n\nIf you have the example open in RStudio, you can click the “Run document” button, or in your terminal run quarto serve example.qmd. Either approach should render the example survey into a shiny app that you can preview in a browser. Don’t worry just yet about setting up your database or making the survey live - for now, we’re going to focus on designing the survey and running it locally to preview it. The example survey should look like this:"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#adding-pages",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#adding-pages",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Adding pages",
    "text": "Adding pages\nIn surveydown, pages are delineated using “fences”, like this:\n\n::: {#welcome .sd-page}\n\nPage 1 content here\n\n:::\n\n::: {#page2 .sd-page}\n\nPage 2 content here\n\n:::\n\nAs you can see, we use three colon symbols :::, called a “fence”, to mark the start and end of pages. This notation is commonly used in Quarto for a variety of use cases, like defining subfigures in images.\nIn the starting fence, you need to define a page name (e.g. welcome and page2 in the example above) and you need to define the class as .sd-page. Then anything you put between the page fences will appear on that page.\nTo navigate to the next page, you need to insert a sd_next() function call inside a code chunk, like this:\n\n```{r}\nsd_next(next_page = 'page2')\n```\n\nThe above code chunk will create a “Next” button that goes on to page 2 that looks like this:\n\n\nNext\n\n\nYou would need to place the code chunk in between the ::: fences of the welcome page in order to have a “Next” button that goes on to page 2. You can also send the user to other pages by just changing the next_page argument. Finally, you can also change the label of the button by changing the label argument, like this:\n\n```{r}\nsd_next(next_page = 'page2', label = 'Next page')\n```\n\n\n\nNext page"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#adding-questions",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#adding-questions",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Adding questions",
    "text": "Adding questions\nEvery survey question is created using the sd_question() function inside a code chunk. The question type is defined by the type argument. For example, to add a multiple choice question, you could insert the following code chunk:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n```\n\nThe above code chunk will create a multiple choice question that looks like this:\n\n\n\n\nWhich is your favorite type of penguin? *\n\n\n\n\n\nAdélie\n\n\n\n\n\nChinstrap\n\n\n\n\n\nGentoo\n\n\n\n\n\n\n\n\nThe sd_question() function can be used to create a variety of question types, like text input, select drop down choices, and more by changing the type argument.\nThe function has many other arguments for customizing the look and feel of the question (e.g., height and width, etc.)."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#the-server-chunk",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#the-server-chunk",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "The server chunk",
    "text": "The server chunk\nAt the very bottom of the .qmd file is a special “server” code chunk (that’s the #| context: server bit) that defines the app server. This is where you can customize and control the survey flow logic as well as where you define the database that will store the survey response data. It looks like this:\n\n```{r}\n#| context: server\n\n# Define the database settings\ndb &lt;- sd_database()\n\n# Define the configuration settings\nconfig &lt;- sd_config()\n\n# The sd_server() function initiates your survey - don't change this\nsd_server(\n  input   = input,\n  session = session,\n  config  = config,\n  db      = db\n)\n```\n\nThe sd_database() function is where you set up your database. The sd_server() function makes everything run, which you can safely ignore - just don’t change it and all will be good!\nThe middle part (the sd_config() function) is where you can define custom control logic for the survey, such as conditional display (conditionally displaying a question based on responses to questions), or conditional skip (conditionally sending the respondent to a page based on responses to questions)."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#going-live",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#going-live",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Going live!",
    "text": "Going live!\nOnce you are happy with your survey, you can deploy it live to any server of your choice. Since it’s a shiny app, you can deploy it to shinyapps.io for free!"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#conditional-display",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#conditional-display",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Conditional display",
    "text": "Conditional display\nLet’s say we had a fourth option for “other” in our multiple choice question about penguins. If the respondent chose it, you may want a second question to popup that allows them to specify the other penguin type. To implement this, you would need to define both questions, e.g.:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo',\n    'Other'     = 'other'\n  )\n)\n\nsd_question(\n  type  = \"text\",\n  id    = \"penguins_other\",\n  label = \"Please specify the other penguin type:\"\n)\n```\n\nThen in the server code chunk, you could use the show_if argument to define that the penguins_other question would only be shown if the respondent chose the other option in the penguins question, like this:\n\nconfig &lt;- sd_config(\n  show_if = tibble::tribble(\n    ~question_id,  ~question_value, ~target,\n    \"penguins\",    \"other\",         \"penguins_other\"\n  )\n)\n\nThis will make the penguins_other question only appear if the respondent chose the other option in the penguins question, like this:\n\n\n\n\nHere we’re using the tibble::tribble() function to define a data frame with three columns:\n\nquestion_id: The id of the triggering question.\nquestion_value: The triggering value.\ntarget: The id of the target question to display.\n\nYou don’t have to use tibble::tribble(), and in fact if you have a lot of show_if conditions, then you could create a csv file with all of your conditions in it and read it in to set the show_if conditions (just make sure the header has the same three column names), e.g.:\n\nconfig &lt;- sd_config(\n  show_if = readr::read_csv('path/to/show_if_conditions.csv')\n  )\n)"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#conditional-skip",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#conditional-skip",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Conditional skip",
    "text": "Conditional skip\nOften times you’ll want to screen people out of a survey based on responses to questions. For example, let’s say you only wanted to only include people who own a vehicle. On your first page (e.g., with page name welcome), you could screen out people who do not own a vehicle.\nFirst, define a question about their vehicle ownership, e.g.:\n\n```{r}\nsd_question(\n  type  = 'mc',\n  id    = 'vehicle_ownership',\n  label = \"Do you own your vehicle?\",\n  option = c(\n    'Yes' = 'yes',\n    'No'  = 'no'\n  )\n)\n```\n\nThen in the server code chunk, you could use the skip_if argument in sd_config() to define the behavior of the next button on the welcome page, like this:\n\nconfig &lt;- sd_config(\n  skip_if = tibble::tribble(\n    ~question_id,        ~question_value, ~target,\n    \"vehicle_ownership\", \"no\",            \"screenout\"\n  )\n)\n\nThis sets up a condition where if the respondent chooses no on the vehicle_ownership question, they will be sent to a page named screenout. You could put such a page at the end of the survey, something like this:\n\n::: {#screenout .sd-page}\n\nSorry, but you are not qualified to take our survey.\n\n:::\n\nNotice that I don’t have a sd_next() on this screenout page. That is how you define an end point for the survey taker. If there’s no “Next” button, then they cannot navigate anywhere else, so the survey is over."
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#required-responses",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#required-responses",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Required responses",
    "text": "Required responses\nBy default, no questions are required. However, you can make questions required by adding the question id to the required argument in sd_config(), like this:\n\nconfig &lt;- sd_config(\n  required_questions = c(\"vehicle_ownership\", \"penguins_other\")\n)\n\nThis will make the respondent unable to proceed until they have answered the required questions. It will also place a red asterisk (*) next to the question label to indicate that the question is required.\nYou can also make all questions required by setting all_questions_required = TRUE like this:\n\nconfig &lt;- sd_config(\n  all_questions_required = TRUE\n)"
  },
  {
    "objectID": "blog/2024-08-21-introducing-surveydown/index.html#reactivity",
    "href": "blog/2024-08-21-introducing-surveydown/index.html#reactivity",
    "title": "Introducing surveydown: A markdown-based framework for generating surveys with Quarto and shiny",
    "section": "Reactivity",
    "text": "Reactivity\nOne other feature that is particularly powerful is the ability to use R code in your survey via Shiny’s reactive programming. This allows you to make your survey more interactive and to use the full power of R to create custom functionality.\n\nDemo 1: Displaying content based on previous responses\nLet’s say you wanted to create a survey that asked the respondent’s name, and then displayed a personalized message based on their name. You could do this by first asking their name:\n\nsd_question(\n  type  = \"text\",\n  id    = \"name\",\n  label = \"What is your name?\"\n)\n\nThen you can use the sd_display_value(\"name\") function to display the value of the name question in other parts of your survey. For example:\n\nWelcome, `r sd_display_value(\"name\")`!\n\nWhich would render as something like “Welcome, Dave!” (assuming the respondent entered “Dave” in the name question). This works because the sd_display_value() function is reactive, meaning it will update the display based on the respondent’s responses.\n\n\nDemo 2: Displaying randomized question labels\nLet’s say you wanted to show a series of questions, but you wanted to randomize the labels shown for each question. You could do this by first defining a list of labels, and then using the sd_question_reactive() function to create a question that will display a random label from the list.\nFor example, let’s ask the respondent to rate different car brands from a random set of brands. You could first pre-define the randomized sets of brands for each respondent and store it as a csv file, like this:\n\nbrands &lt;- c(\"Toyota\", \"Ford\", \"Chevrolet\", \"Honda\", \"Nissan\", \"Tesla\")\ndesign &lt;- data.frame(\n  respondent_id = rep(1:10, each = 3),\n  brand = unlist(lapply(1:10, function(x) sample(brands, 3, replace = FALSE)))\n)\nwrite_csv(design, \"design.csv\")\n\nThis would make a design file that looks like this:\n\n\n#&gt;   respondent_id     brand\n#&gt; 1             1    Toyota\n#&gt; 2             1      Ford\n#&gt; 3             1 Chevrolet\n#&gt; 4             2    Toyota\n#&gt; 5             2 Chevrolet\n#&gt; 6             2      Ford\n\n\nNote that this would not be done in your survey.qmd file - it’s just a one-time thing to create the design (probably stored in an R file).\nThen in your server code chunk, you could read in the design file and use it to randomize the labels for each question based on a randomly chosen respondent:\n\ndesign &lt;- read_csv(\"design.csv\")\nresp_id &lt;- sample(design$respondent_id, 1)\ndf_resp &lt;- design %&gt;% filter(respondent_id == resp_id)\n\noptions &lt;- c(1, 2, 3)\nnames(options) &lt;- df_resp$brand\n\nsd_question_reactive(\n  type  = \"mc\",\n  id    = \"brands\",\n  label = \"Which of these brands do you like best?\",\n  option = options\n)\n\nHere the sd_question_reactive() function is used because the labels depend on the randomly chosen respondent. This means the labels will be different for each respondent.\nSince this is a reactive question, this code must be placed inside the server code chunk, not where you want it to appear in the survey. To define where in the survey the question should appear, you use the sd_display_question() function with the id set to the same value as the id in the sd_question_reactive() function, like this:\n\nsd_display_question(id = \"brands\")\n\nNow the brands question will be displayed in the survey where you put this code chunk.\nNote that all question responses are automatically saved to the database, but if you wanted to store some other value (e.g. the randomly chosen respondent_id), you could do that with the sd_store_value() function, like this:\n\nsd_store_value(resp_id)"
  }
]